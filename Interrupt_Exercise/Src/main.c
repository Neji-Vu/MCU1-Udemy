/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define IRQNO_USART2 38U
#define IRQNO_TIM5 50U
#define pISPR_BASE 0XE000E200
#define pISER_BASE 0xE000E100
#define pIPR_BASE 0xE000E400

uint8_t count = 0;

void set_priority(uint8_t IRQNO, uint8_t priortity_value){
	// Select the IPR register number
	uint32_t *pIPRx = (uint32_t*)pIPR_BASE + (IRQNO / 4);

	// Clear bit at IPR register
	//	*pIPRx &= ~(0xFF << ((IRQNO % 4) * 8));
	// Select the bit at IRQ number
	*pIPRx |= (priortity_value << ((IRQNO % 4) * 8));
}

int main(void)
{

	// Configure the priority for interrupts
	set_priority(IRQNO_USART2, 0x80);
	set_priority(IRQNO_TIM5, 0x70);


	// Enable Pending Register of USART2
	uint32_t *pISPR_USART2 = (uint32_t*)pISPR_BASE + (IRQNO_USART2 / 32);
	*pISPR_USART2 |= (1 << (IRQNO_USART2 % 32));

	// Enable Pending Register of TIM5
	uint32_t *pISPR_TIM5 = (uint32_t*)pISPR_BASE + (IRQNO_TIM5 / 32);
	*pISPR_TIM5 |= (1 << (IRQNO_TIM5 % 32));


	// Enable Set-enable Register of USART2
	uint32_t *pISER_USART2 = (uint32_t*)pISER_BASE + (IRQNO_USART2 / 32);
	*pISER_USART2 |= (1 << (IRQNO_USART2 % 32));


    /* Loop forever */
	for(;;);
}


void USART2_IRQHandler(){
	count++;
//	// Enable Set-enable Register of TIM5
//	uint32_t *pISER_TIM5 = (uint32_t*)pISER_BASE + (IRQNO_TIM5 / 32);
//	*pISER_TIM5 |= (1 << (IRQNO_TIM5 % 32));
//	while(1);
}

void TIM5_IRQHandler(){
	count++;
	while(1);
}
